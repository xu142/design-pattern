# 命令模式
## 定义
> 命令模式是一个高内聚的模式，其将一个请求封装成一个对象，从而让使用不同的请求把客户端参数化，
> 对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能
## 三个角色
### Receive 接收者角色
> 该角色就是干活的角色，命令传递到这里是应该被执行的，具体到我们上面的例子中就是Group的三个实现类
## Command 命令角色
> 需要执行的所有命令都在这里声明
## Invoker 调用者角色
> 接收到命令，并执行命令。
## 应用
### 优点
#### 类间解耦
> 调用者角色与接收者角色之间没有任何依赖关系，
> 调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底是哪个接收者执行
#### 可扩展性
> Command 的子类可以非常容易的扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合
#### 命令模式结合其他模式会更优秀
> 命令模式可以结合责任链模式，实现命令族解析任务；
> 结合模板方法模式，则可以减少Command子类的膨胀问题
### 缺点
> 如果有N个命令，问题就出来了，Command的子类就有N个，这个类膨胀的非常大
### 使用场景
> 只要任务是命令的地方就可以采用命令模式
## 扩展
### 一个命令多个执行组
### 命令发出，反悔问题
> 1.结合备忘录模式还原最后状态，该方法适合接收者为状态的变更情况，而不适合事件处理；
> 2.增加一个新的命令，实现事件的回滚。
## 最佳实践
> 每一个模式到实际应用的时候都有一些变形，命令模式的Receiver在实际应用中一般都会被封装掉
> （除非非常必要，例如撤销处理），那是因为在项目中：约定的优先级更高，每一个命令是对一个或多个
> receiver的封装，我们可以在项目中通过有意义的类名或命令名处理命令角色和接收者角色的耦合关系（这就是约定）
> ，减少高层模块（client类）对底层模块（Receiver角色类)的依赖关系，提高系统整体的稳定性。可以在实际的项目
> 开发中采用封闭Receiver的方式，减少Client对Receiver的依赖。
> 也就是说 在Command 类中会定义一个子类的全局共享变量，具体的command的实现类中会声明这个默认接受者。