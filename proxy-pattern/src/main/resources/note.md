# 代理模式
## 定义
> 为其他对象提供一种代理以控制对这个对象的访问
## 三个角色
### Subject 抽象主题角色
> 抽象主题类 可以是抽象类也可以是接口，是一个最普通的业务类型定义，无特殊要求
### RealSubject 具体主题角色
> 也叫做被委托角色、被代理角色。是业务逻辑的具体执行者
### Proxy   代理主题角色
> 也叫做委托类、代理类。它负责对真实角色的应用。把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实
> 角色处理完毕前后做预处理和善后处理工作
## 优点
### 职责清晰
> 真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是变成简洁清晰
### 高扩展性
> 具体主题角色是随时都会发生变化的，只要他实现了接口，那代理类完全可以在不做任何修改额情况下使用
### 智能化
## 扩展
### 普通代理
> 普通代理他的要求是客户端只能访问代理角色，而不能访问真实角色。
> 
> 在该模式下，调用者只知代理而不用知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响，真实的主题角色想怎么修改就怎么
> 修改，对高层模块没有任何的影响。只要实现了接口所对应的方法，该模式非常适合对扩展性要求较高的场合。
> 当然，在实际的项目中，一般都是约定来禁止new 一个真实的角色，这也是一个非常好的方案。
### 强制代理
> 一般的思维都是通过代理找到真实的角色，但是强制带离却是要强制，你必须通过真实角色查找到代理角色，否则不能访问。
> 
> 强制代理的概念就是要从真实角色查找到代理角色，不允许直接访问真实角色。高层模块只要调用getProxy就可以访问真实角色的所有方法
> 它根本不需要产生一个代理出来，代理的管理已经由真实角色自己完成
> 
> 强制代理的真实角色增加了一个私有方法，检查是否是自己指定的代理，是指定的代理允许访问，否则不允许访问。
### 动态代理
> 动态代理是在实现阶段不用关心代理谁,而在运行阶段才指定代理哪一个对象。
> 
> 相对来说，自己写代理类的方式就是静态代理
> 
> 面向切面编程，也就是AOP,其核心就是采用了动态代理机制。
> 
> 而其中invoke方法是接口InvocationHandler定义必须实现的，他完成对真实方法的调用。
> 
> 要实现动态代理的首要条件是：被代理类必须实现一个接口，
#### InvocationHandler 
> 动态代理是根据被代理的接口生成所有的方法，也就是说给定一个接口，动态代理会宣称“我已经实现该接口下的所有方法了”,
> 那么动态代理怎么才能实现被代理接口中的方法呢？
> 
> 默认情况下所有的方法返回值都是空的，代理已经实现了，但是没有任何的逻辑含义。
> 所以通过InvocationHandler接口，所有的方法都由改Handler来进行处理，即所有被代理的方法都由InvocationHandler接管实际的处理任务。
>
### 代理是有个性的
> 一个类可以实现多个接口，完成不同任务的整合。
>
> 也就是说代理类不仅仅可以实现主题接口，也可以实现其他接口完成不同的任务，
> 而且代理的目的是在目标对象方法的基础上做增强，这种增强的本质通常就是对目标对象的方法进行拦截和过滤。
> 
> 
***
