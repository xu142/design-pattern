# 备忘录模式
## 1 定义
> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。
## 1.1 角色
### 1.1.1 Originator 发起人角色
> 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据
### 1.1.2 Memento 备忘录角色
> 负责存储Originator 发起人对象的内部状态，在需要的时候提供发起人需要的内部状态
### 1.1.3 Caretaker 备忘录管理员角色
> 对备忘录进行管理、保存和提供备忘录
## 2 应用
### 2.1 场景
> 需要保存和恢复数据的相关状态场景
> 
> 提供一个可回滚的操作
> 
> 需要监控的副本场景中。
> > 比如要监控一个对象的属性，但是监控又不应该作为系统的主业务来调用，他只是边缘应用，即使出现监控不准、错误报警也影响不大，因此一般的做法是备份一个主线程
> >中的对象，然后由分析程序来分析。
> 
> 数据库连接的事务管理就是用的备忘录模式。
### 2.2 注意事项
#### 2.2.1 备忘录的生命期
> 备忘录创建出来就要在“最近”的代码中使用，要主动管理它的生命周期，建立就要使用，不使用就要立即删除其引用，等待垃圾回收器对他的回收处理。
#### 2.2.2 备忘录的性能
> 不要在频繁建立备份的场景中使用备忘录模式，原因有二：
> 
>1.控制不了备忘录建立的对象数量
> 
> 2.大对象的建立是要消耗资源的
## 3.扩展
### 3.1 clone方式的备忘录
> 使用clone方式的备忘录模式，可以使用在比较简单的场景或者比较单一的场景中，尽量不要与其他的对象产生严重的耦合关系。
### 3.2 多状态的备忘录模式
> 增加一个BeanUtils类
### 3.3 多备份的备忘录
> 之前的备忘录模式对于一个确定的发起人，永远只有一份备份。
> 
> 检查点（Check Point）
> 也就是在备份的时候做的戳记，系统级的备份一般是时间戳，程序的检查点一般是一个有意义的字符串
#### 3.3.1 内存溢出问题
> 该备份一旦产生就装入内存，没有任何销毁的意向，这是非常危险的。因此，在系统设计时，要严格限定备忘录的创建，建议增加Map的上限，否则系统很容易产生
> 内存溢出情况。
### 3.4 封装的更好一点
> 在系统管理上，一个备份的数据是完全、绝对不能修改的，他保证数据的洁净，避免数据污染而使备份失去意义。
> 设计上，也存在同样的问题，备份是不能被篡改的，也就是说缩小备份出的备忘录的阅读权限，保证只能是发起人可读就可以了。
> 使用内置类
#### 3.4.1 双接口设计
> 在系统设计时，如果考虑对象的安全问题，则可以提供两个接口，一个是业务的正常接口，实现必要的业务逻辑，叫做宽接口。
> 
> 另外一个接口是一个空接口，什么方法都没有，其目的是提供给子系统外的模块访问，比如容器对象，这个叫做窄接口。由于窄接口没有提供任何操纵数据的方法，因此相对
> 来说比较安全。