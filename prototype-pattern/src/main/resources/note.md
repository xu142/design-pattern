# 原型模式
## 定义
> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
## 优点
### 性能优良
> 原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象的时候，原型模式可以更好的体现其优点
### 逃避构造函数的约束
> 这既是他的优点也是缺点，直接在内存中拷贝，构造函是不会执行的。
> 优点是减少了约束，缺点也是减少了约束。
## 使用场景
### 资源优化场景
> 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等
### 性能和安全要求的场景
> 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式
### 一个对象多个修改者的场景
> 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用
## 注意事项
### 构造函数不会被执行
> 一个实现了Cloneable并重写了clone方法的类A，有一个无参构造或有参构造B，通过new关键字产生了一个对象S,再然后通过S.clone()方式
> 产生了一个新对象T，那么在对象拷贝时构造函数B是不会执行的。
### 深拷贝和浅拷贝
#### 浅拷贝
> Java做了一个偷懒的拷贝动作，Object类提供的方法clone只是拷贝本对象，其对象内杯的数组、引用对象等都不拷贝，还是指向原生对象的
> 内部元素地址，这种拷贝就叫做浅拷贝
> 
> 注意：
> 使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝，
> 1：类的成员变量，而不是方法内变量；
> 2：必须是一个可变的引用对象，而不是一个原始类型或不可变对象

#### 深拷贝
> 对私有的类变量进行独立的拷贝。就实现了完全的深拷贝。
> 深拷贝还有一种实现方式是通过自己写二进制流来操作对象，然后实现对象的深拷贝。
> 
> 注意：
> 深拷贝和浅拷贝建议不要混合使用，特别是在设计类的继承的时候，父类有多个引用的情况就非常复杂，建议的方案是深拷贝和浅拷贝分开实现。
### clone 和 final
> 对象的clone 和对象内的final关键字是有冲突的。要使用clone方法，类的成员变量上就不要增加final关键字
## 实践
> 原型模式先产生出一个包含大量共有信息的类，然后可以拷贝出副本，修正细节信息，建立了一个完整的个性对象。
> 一个对象的产生可以不由零起步，直接从一个已经具备一定雏形的对象克隆，然后再修改为生产需要的对象。