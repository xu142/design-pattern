# 单例模式
## 饿汉模式
程序启动的时候直接运行加载，后续有外部需要使用的时候获取
### 问题
无论程序是否用到，都会在程序启动之初进行创建，容易产生垃圾对象，造成内存浪费
## 懒汉模式（线程不安全）
先不急着创建对象，等需要的时候再创建对象
### 问题
线程安全问题，不支持多线程。多个访问者同时去获取对象实例，就会创建多个实例
## 懒汉模式（线程安全）
在方法上加锁从而实现线程安全的目的
### 问题
由于把锁加到方法上之后，所有的访问都需要锁从而导致资源浪费
## （懒汉模式）双重检查
直接在方法上加锁，锁的粒度太粗，导致资源浪费，细化锁之后又会导致线程不安全，所以加上双重检查
### 问题
需要加上volatile，不加volatile的话还是会出现问题，原因在于
instance = new Singleton() 这句，实际上在jvm层面做了如下三件事
1.给instance分配内存
2.调用Singleton的构造函数来初始化成员变量
3.将instance对象指向分配的内存空间
但是jvm的即时编译器中存在指令重排序的优化，也就是说第二步和第三步是不能保证的，可能最后是1-2-3也可能是1-3-2。如果是后者即3执行完毕，2未执行之前，
被线程2抢占了，这是instance非null，但却没有初始化，所以线程2会直接返回instance，然后使用就会报错
## 使用类的内部类
使用类的静态内部类既保证了线程安全又保证了懒加载，这是因为jvm可以保证多线程并发访问的正确性，类的构造方法在多线程情况下可以被正确的加载
## 使用CAS
使用cas可以不用加锁，而是基于cas的忙等算法，依赖底层硬件的实现，相对于锁他没有线程切换和阻塞的额外消耗，可以支持较大的并行度
### 问题
CAS的一个重要缺点在于一直忙等一直执行不成功，会对cpu造成比较大的执行开销
## 枚举单例
java effective中，枚举可以有效防御两种破坏单例的行为，即单例产生多个实例。反射和序列化。
因为枚举是线程安全的，并且只会加载一次，并且不会被反射破坏
