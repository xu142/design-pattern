# 门面模式
## 1 定义
> 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。
> 门面模式提供一个高层次的接口，使得子系统更易于使用。
### 1.1 角色
#### 1.1.1 Facade 门面角色
> 客户端可以调用这个角色的方法。此角色知晓子系统的所哟功能和责任。
> 
> 一般情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去，也就是说该角色没有实际的业务逻辑，只是一个委托类。
#### 1.1.2 subsystem 子系统角色
> 可以同时有一个或者多个子系统。
> 每一个子系统都不是一个单独的类，而是一个类的集合。
> 子系统并不知道门面的存在。对于子系统而言，门面仅仅是另外一个客户端而已。
## 2 应用
### 2.1 优点
#### 2.1.1 减少系统的相互依赖
> 如果不使用门面模式，外界访问直接深入到子系统内部，相互之间是一种强耦合关系，这样的强依赖是系统设计所不能接受的，门面模式的出现就很好的解决了问题。
> 所有的依赖都是对门面对象的依赖，与子系统无关
#### 2.1.2 提高了灵活性
> 依赖减少了，灵活性自然提高了。
#### 2.1.3 提高安全性
> 想让访问系统哪些业务就开通哪些逻辑。
### 2.2 缺点
> 不符合开闭原则，对修改关闭，对扩展开放。
> 出现问题只能修改门面对象。
### 3 场景
> 为一个复杂的模块或子系统提供一个供外界访问的接口
> 
> 子系统相互独立--外界对子系统的访问只要黑箱操作即可
> 
> 预防低水平人员带来的风险扩散
### 4 注意事项
#### 4.1 一个子系统可以有多个门面
> 门面已经庞大到不能忍受的程序
> > 比如一个数据库的操作的门面可以拆分成增删改等
> 子系统可以提供不同访问路径
> >  引用原来的门面，并对外提供唯一的访问子系统的方法。
#### 4.2 门面不参与子系统内的业务逻辑
> 门面系统只是提供一个访问子系统的路径而已，不应该也不能参与具体的业务逻辑，否则会产生一个倒依赖的问题：
> > 子系统必须依赖门面才能被访问，这样不仅破坏了单一职责原则，同时也破坏了系统的封装性。
> 解决方法是可以建立一个封装类，封装完毕后提供给门面对象。
> 
> 通过这样一次封装，门面对象不参与业务逻辑。在门面模式种，门面角色应该是稳定，他不应该经常变化，一个系统一旦投入运行他就不应该被改变，他是一个系统对外的接口
> 