# 策略模式
## 1.1 定义
> 定义一组算法，将每个算法都封装起来，并且使他们之间可以互换
### 1.1.1 三个角色
#### 1.1.1.1 Context 封装角色
> 它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化
#### 1.1.1.2 Strategy 抽象策略角色
> 策略、算法家族的抽象，通常为借口，定义每个策略或算法必须具有的方法和属性。
#### 1.1.1.3 ConcreteStrategy 具体策略角色
> 实现抽象策略中的操作，该类含有具体的算法
### 和代理模式的差别
> 策略模式的封装角色和被封装的策略类不是同一个借口，如果是同一个接口那就成为了代理模式。
## 2.应用
### 2.1优点
#### 2.1.1 算法可以自由切换
> 这是策略本身定义的，只要实现抽象策略，他就成为策略家族的一个成员。通过封装角色对其进行封装，保证对外提供“可自由切换”的策略
#### 2.1.2 避免多重条件判断
> 如果没有策略模式，一个策略家族有5个策略算法。设计起来就需要多重的条件语句。
> 而多重条件语句不易维护，而且出错的概率大大的增强。
> 
> 使用策略模式后，可以由其他模块决定采用何种策略，策略家族对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断
#### 2.1.3 扩展性良好
### 2.2 缺点、
#### 2.2.1 策略数量增多
> 每一个策略都是一个类，复用的可能性很小，类数量增多
#### 2.2.2 所有的策略类都需要对外暴露
> 上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与迪米特法则是相违背的
## 3.使用场景
> 多个类只有在算法或行为上稍有不同的场景。
> 
> 算法需要自由切换的场景
> 
> 需要屏蔽算法规则的场景
### 4.注意事项
> 如果系统中一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题。
### 5.扩展
#### 策略枚举
> 把原有定义在抽象策略中的方法移植到枚举中，每个枚举成员就成为一个具体策略。
> 
> 他是一个枚举
> 
> 他是一个浓缩了的策略模式的枚举
> 策略枚举是一个非常优秀和方便的模式，但是受枚举类型的限制。每个枚举项都是public、final、static的，
> 扩展性收到了一定的约束，因此在系统开发中，策略枚举一般担当不经常发生变化的角色
### 6.最佳实践
